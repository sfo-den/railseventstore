class Profile
  def initialize(options)
    @options = options.dup
  end

  private attr_reader :options

  def client
    postgres? ? "RailsEventStore::JSONClient.new" : "RailsEventStore::Client.new"
  end

  def data_type
    postgres? ? "jsonb" : "binary"
  end

  private

  def postgres?
    database.downcase.eql?("postgresql")
  end

  def database
    options.fetch(:database)
  end
end

profile = Profile.new(options)

gem "rails_event_store", "~> 2.8.1"

initializer 'rails_event_store.rb', <<~CODE
  require 'rails_event_store'
  require 'aggregate_root'
  require 'arkency/command_bus'

  Rails.configuration.to_prepare do
    Rails.configuration.event_store = #{profile.client}
    Rails.configuration.command_bus = Arkency::CommandBus.new

    AggregateRoot.configure do |config|
      config.default_event_store = Rails.configuration.event_store
    end

    # Subscribe event handlers below
    Rails.configuration.event_store.tap do |store|
      # store.subscribe(InvoiceReadModel.new, to: [InvoicePrinted])
      # store.subscribe(lambda { |event| SendOrderConfirmation.new.call(event) }, to: [OrderSubmitted])
      # store.subscribe_to_all_events(lambda { |event| Rails.logger.info(event.event_type) })

      store.subscribe_to_all_events(RailsEventStore::LinkByEventType.new)
      store.subscribe_to_all_events(RailsEventStore::LinkByCorrelationId.new)
      store.subscribe_to_all_events(RailsEventStore::LinkByCausationId.new)
    end

    # Register command handlers below
    # Rails.configuration.command_bus.tap do |bus|
    #   bus.register(PrintInvoice, Invoicing::OnPrint.new)
    #   bus.register(SubmitOrder,  ->(cmd) { Ordering::OnSubmitOrder.new.call(cmd) })
    # end
  end
CODE

after_bundle do
  rails_command 'db:create'
  generate "rails_event_store_active_record:migration --data-type=#{profile.data_type}"
  rails_command 'db:migrate'
  route "mount RailsEventStore::Browser => '/res' if Rails.env.development?"
end
